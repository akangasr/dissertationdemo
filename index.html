<!DOCTYPE html>
<html>
<title>Machine Learning Methods for Interactive Search Interfaces and Cognitive Models</title>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<link rel="stylesheet" href="https://www.w3schools.com/w3css/4/w3.css">
<link rel="stylesheet" href="https://www.w3schools.com/lib/w3-theme-black.css">
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">
<link rel="stylesheet" href="https://code.jquery.com/ui/1.12.1/themes/base/jquery-ui.css">

<style>
html,body,h1,h2,h3,h4,h5,h6 {
  font-family: "Roboto", sans-serif;
}
.main {
  margin-top: 100px;
  margin-left: 250px;
}
#topbar {
  height: 90px;
  position: fixed;
  z-index: 100;
  top: 0px;
  left: 0px;
  right: 0px;
  white-space: nowrap;
  padding: 0px;
  float: left;
}
#topbar h4 {
  padding: 8px 16px;
}
#sidemenu {
  width: 250px;
  padding-top: 90px;
  top: 0px;
  bottom: 0px;
  height: inherit;
  display: block;
}
#topmenubar {
  background-color: #f0f0f0;
  display: none;
  width: 100%;
  height: 40px;
  align-items: center;
  z-index: 102;
  position: fixed;
  top: 0;
  right: 0;
  left: 0;
}
#topmenu {
  display: none;
  z-index: 101;
  width: 100%;
  padding-top: 0;
  height: auto;
  position: fixed;
  top: 40px;
  left: 0;
  bottom: auto;
  right: 0;
  box-shadow: 0 0 10px rgba(0, 0, 0, 0.5);
}
.top-menu-bar-button {
    width: 100%;
    padding: 10px 15px;
    text-decoration: none;
    padding-left: 40px;
}
.top-menu-bar-button span {
    display: block;
    position: absolute;
    top: 50%;
    transform: translateY(-50%);
    left: 15px;
}
.top-menu-bar-button span:last-child {
    font-size: 24px;
    display: none; /* Hide cross icon by default */
}
p {
  font-family: "Roboto", sans-serif;
  font-size: 20px;
  max-width: 800px;
}
.figure {
  margin-top: 40px;
  max-width: 800px;
  clear: both;
}
.search-ui {
  width: 800px;
  height: 700px;
  border-style: solid;
  border-width: 1px;
  border-color: black;
}
.search-bar {
  height: 10%;
  clear: both;
  padding: 5px;
}
.search-top {
  height: 40%;
  clear: both;
  border-style: solid;
  border-width: 1px 0px 0px 0px;
  border-color: black;
}
.search-bottom {
  height: 50%;
  clear: both;
  border-style: solid;
  border-width: 1px 0px 0px 0px;
  border-color: black;
}
.search-box-label {
  font-size: 20px;
  float: left;
}
.search-box {
  width: 100%;
  clear: both;
}
.search-selection {
  width: 20px;
  margin-left: 5px;
  margin-top: 10px;
  margin-right: 30px;
  float: left;
}
.search-history {
  width: 45%;
  height: 100%;
  float: left;
  overflow-y: scroll;
  padding: 5px;
}
.search-history-header {
  font-size: 20px;
}
.search-model {
  width: 45%;
  height: 100%;
  float: left;
  overflow-y: scroll;
  padding: 5px;
}
.search-model-header {
  font-size: 20px;
}
.search-results {
  width: auto;
  height: 100%;
  overflow-y: scroll;
  border-style: solid;
  border-width: 0px 0px 0px 1px;
  border-color: black;
  padding: 5px;
}
.search-item {
  width: auto;
  height: 100%;
  overflow-y: scroll;
  border-style: solid;
  border-width: 0px 0px 0px 1px;
  border-color: black;
  padding: 5px;
}
.search-result-header {
  font-size: 20px;
}
.search-result-title {
  font-size: 15px;
  margin: 0px;
  padding: 0px;
}
.search-result-title:hover {
  font-weight: bold;
  cursor: pointer;
}
.search-result-text {
  font-size: 15px;
}
.keyword-item {
  clear: both;
}
.keyword-slider {
  background-image: linear-gradient(to right, coral , palegreen);
  width: 200px;
  height: 10px;
  margin-right: 20px;
  margin-top: 5px;
  float: right;
}
.keyword-item-name {
  font-size: 15px;
  float: left;
}

@media only screen and (max-width: 1100px) {
  .main {
    margin-top: 0px;
    margin-left: 0px;
  }
  #topbar {
    height: auto;
    margin-top: 40px;
    white-space: normal;
    position: relative;
  }
  #topbar h4 {
    font-size: 16px;
    line-height: 18px;
  }
  #sidemenu {
    display: none;
  }
  #topmenubar {
    display: flex;
  }
  .w3-container {
    padding-top: 20px;
    padding-bottom: 20px;
  }
  .w3-container h1 {
    font-size: 24px;
    line-height: 26px;
  }
  .w3-container h2 {
    font-size: 20px;
    line-height: 22px;
  }
  .w3-container p {
    font-size: 15px;
  }
  .figure {
    width: 100%;
  }
  .search-ui {
    width: 100%;
    height: auto;
  }
  .search-bar {
    width: 100%;
    height: 130px;
    border-style: solid;
    border-width: 0px 0px 1px 0px;
    border-color: black;
  }
  .search-box-label {
    clear: left;
  }
  .search-results {
    float: none;
    width: 100%;
    height: 150px;
    border-style: solid;
    border-width: 1px 0px 0px 0px;
    border-color: black;
  }
  .search-item {
    float: none;
    width: 100%;
    height: 150px;
    border-style: solid;
    border-width: 1px 0px 0px 0px;
    border-color: black;
  }
  .search-model {
    float: none;
    width: 100%;
    height: 150px;
    border-style: solid;
    border-width: 1px 0px 0px 0px;
    border-color: green;
  }
  .search-history {
    float: none;
    width: 100%;
    height: 150px;
  }
  .search-top {
    clear: none;
    width: 100%;
    height: auto;
    border-width: 0px;
  }
  .search-bottom {
    clear: none;
    width: 100%;
    height: auto;
    border-width: 0px;
  }
}
</style>
<body>

<div class="top-menu-bar" id="topmenubar">
  <a class="top-menu-bar-button" href="#menu" onclick="toggle_mobile_menu(event);">
    <span>&#9776;</span>
    <span>&times;</span>
    Menu
  </a>
</div>

<div class="top w3-theme w3-top w3-left-align w3-large" id="topbar">
  <h4>
    <b>Machine Learning Methods for Interactive Search Interfaces and Cognitive Models</b>
    <br/>Online demonstration / D.Sc. (tech.) dissertation, Antti Kangasrääsiö, Aalto University, 2018
  </h4>
</div>

<nav class="w3-sidebar w3-bar-block w3-large w3-theme-l5" id="sidemenu">
  <a class="w3-bar-item w3-button w3-hover-black" onclick="change_page('intro')">Introduction</a>
  <a class="w3-bar-item w3-button w3-hover-black" onclick="change_page('usability')">Search AI Usability</a>
  <a class="w3-bar-item w3-button w3-hover-black" onclick="change_page('cognitive')">Cognitive Model Inference</a>
  <a class="w3-bar-item w3-button w3-hover-black" onclick="change_page('author')">Author: Antti Kangasrääsiö</a>
  <a
    class="w3-bar-item w3-button w3-hover-black"
    href="https://aaltodoc.aalto.fi/bitstream/handle/123456789/34495/isbn9789526082516.pdf?sequence=1&isAllowed=y"
    target="_blank">
    Read the book
  </a>
</nav>

<nav class="w3-sidebar w3-bar-block w3-large w3-theme-l5" id="topmenu">
  <a class="w3-bar-item w3-button w3-hover-black" onclick="change_page('intro')">Introduction</a>
  <a class="w3-bar-item w3-button w3-hover-black" onclick="change_page('usability')">Search AI Usability</a>
  <a class="w3-bar-item w3-button w3-hover-black" onclick="change_page('cognitive')">Cognitive Model Inference</a>
  <a class="w3-bar-item w3-button w3-hover-black" onclick="change_page('author')">Author: Antti Kangasrääsiö</a>
  <a
    class="w3-bar-item w3-button w3-hover-black"
    href="https://aaltodoc.aalto.fi/bitstream/handle/123456789/34495/isbn9789526082516.pdf?sequence=1&isAllowed=y"
    target="_blank">
    Read the book
  </a>
</nav>

<div class="main" id="main">

<div class="w3-container" id="intro">
<h1 class="w3-text-teal">Introduction</h1>
<p>Human-computer interaction is experiencing a large change as the services and
applications we use are becoming intelligent. User experience is increasingly
dependent on complex mathematical models that adapt to the feedback and instructions
provided by the user. For example, the search engines we use adjust their
recommendations based on our search history, and social media platforms and
streaming services select the displayed content based on a model of our interests.
It is likely that in the future the vast majority of our services will be personalized.</p>

<p>How to make an intelligent system understandable and easy to use, even though
it uses complex algorithms to drive its behavior? The usability of intelligent
systems has various challenges. This is because, for example, it may be difficult
for the user to predict the effects of her actions. The dissertation presents methods
to improve the usability of search engines that perform online modelling of the
user's interests. The methods visualize the predicted effects of user actions
and change the system dynamic behavior to be easier to control, thus improving
its usability. The methods also highlight possible inconsistencies in the user
feedback, making it easier for the user to spot inconsistencies in her feedback.
The presented methods could be used to improve the usability of various existing
systems for personalized search and recommendation.</p>

<p>How to learn a realistic model of user behavior based on observations from
the real world? Modern user models are still very simple compared to the
complexity of human decision-making. This is due to challenges in inferring
the parameters of more realistic user models. Realistic user models would
enable more accurate predictions of the user's interests and allow more suitable
personalisation for each user. The dissertation proposes a simulation-based
inference method, which allows inference even for complex user models that are
not amenable for traditional gradient-based inference methods. The method is
efficient and able to infer the uncertainty of the parameter values as well.
It is shown to work well with modern reinforcement learning based user models,
as well as models commonly used in cognitive science. Using the proposed method
it could be possible to use more realistic user models in multiple situations
which require personalization and inference of user interests.</p>
</div>


<div class="w3-container" id="usability" style="display: none;">
<h1 class="w3-text-teal">Search AI Usability</h1>

<h2 class="w3-text-teal">Toy Search Engine</h2>
<div class="search-ui" id="search-ui">
  <div class="search-bar" id="search-bar">
      <input type="text" class="search-box" id="search-box" value="printer"></input>
      <div class="search-box-label" id="search-box-label">Show model</div>
      <input type="checkbox" class="search-selection" id="show-model-checkbox" onclick="toggle_show_model()" checked></input>
      <div class="search-box-label" id="search-box-label">Show predictions</div>
      <input type="checkbox" class="search-selection" id="show-predictions-checkbox" onclick="toggle_show_predictions()" checked></input>
      <div class="search-box-label" id="search-box-label">Added control</div>
      <input type="checkbox" class="search-selection" id="use-control-checkbox" onclick="toggle_use_control()" checked></input>
  </div>
  <div class="search-top" id="search-top">
    <div class="search-history" id="search-history"></div>
    <div class="search-results" id="search-results">
      <div class="search-result-header">No results</div>
    </div>
  </div>
  <div class="search-bottom" id="search-bottom">
    <div class="search-model" id="search-model"></div>
    <div class="search-item" id="search-item"></div>
  </div>
</div>
<p>(Dragging of sliders and the accompanying animation only works with a mouse)</p>

<h2 class="w3-text-teal">Model Visualization</h2>
<p>
Intelligent systems rely on a user model for personalizing the user experience.
However, only few systems actually allow the user to see or interact with the
model. The toy search engine above is intended to demonstrate how an interactive
user model could be implemented. This approach to user modelling is called
<i>interactive user modelling</i>.
</p>
<p>
Interactive user modelling has various benefits. First, it allows the user to
take small controlled steps in the search space. The visualization provides
keyword suggestions, making it easier to spot relevant search keywords. As the
user is able to inspect the user model, this increases the user's trust in the
system. Interactive user modelling is also likely to improve the accuracy
of the mental model the user has of the system, as the user has more relevant
information available.
</p>
<p>
Interactive user modelling is also related to the <i>interpretability</i> of
models in general. As the user model may be very complex, it is important to
design the visualization in such a way that the user is able to comprehend
what the model state actually is at any given moment.
</p>


<h2 class="w3-text-teal">Interaction Predictability</h2>
<p>
Interaction is predictable if the user is able to predict in advance what effects
her actions will have on the system. Predictable systems are easier to use, as
it is easier for the user to choose the most suitable action for each situation.
For example, a car that would sometimes turn right when the drive steered left
is not predictable.
</p>
<p>
However, just because the user can see the model does not mean that the user can
predict how her actions will change the model. This means that a distinction needs
to be made regarding the interpretability of the <i>model state</i> and the
interpretability of <i>model dynamics</i>. A visualized model has an interpretable
state if the user can aswer questions such as "what are the features of the
current model that have the largest effect on the predictions the model makes?"
In comparison, the visualized model has interpretable dynamics if the user can
answer to questions such as "how would the most important features of the model
change if I would give this or that feedback?"
</p>
<p>
The dissertation proposes an easy way to make any interpretable model also dynamically
interpretable: use the existing visualization to display the predicted future
model state while the user is deciding the value of the next feedback. This
improves the interpretability of the model dynamics, and allows the user to
construct a more adequate mental model of the system behavior as well. The
method can also be used with any user model that can be visualized.
</p>
<p>
This behavior is demonstrated in the toy search engine, where the predicted model
state and search results are visualized as the user drags a keyword with mouse.
</p>

<h2 class="w3-text-teal">Model Controllability</h2>
<p>
A system is controllable if the user is able to make the system behave in the
way the user wants. Systems that are more controllable are easier to use,
as the user has more influence over the system behavior. For example, a car whose
wheels would only turn half as much as normal would be less controllable and
require more user effort for performing certain manoveurs.
</p>
<p>
In interactive user modelling, one problem with the controllability of the user
model is that the more feedback the user gives, the smaller the relative effect
of each individual piece of feedback. In general, there is no guarantee that
new feedback given by the user will have an effect of certain size to the model
or the predictions, unless one consideres all the previous feedback as well.
</p>
<p>
The dissertation proposes a method for guaranteeing model controllability to
some degree in all situations. Instead of treating user feedback simply as "one
more data point", it is treated as a specific requirement for the next model
state. An optimization algorithm is then used for choosing what data points
should be added to the model training dataset to achieve the end state desired
by the user. The method can be used with any underlying user model for improving
its controllability.
</p>
<p>
This behavior is demonstrated in the toy search engine, where feedback weights
are optimized so that the model conforms to the latest feedback. The weights are
displayed as multipliers after the feedback name. The feature is naturally most
active when there is a large amount of existing feedback.
</p>

<h2 class="w3-text-teal">Feedback Visualization</h2>
<p>
A system is transparent if the user can predict the system behavior from a
visualization of the system state. For example, if a car dashboard would
not have a fuel gauge, the driver could not predict when pressing the gas pedal
would take her forward. Transparency contributes to the predictability of
interaction and the ability of the user to control the system state.
</p>
<p>
As discussed above, the behavior of a system that models its users may depend
on a long history of feedback given by the user. If the user is not aware of
all the data that contributes to the behavior of the user model, this makes
the system less transparent. Furthermore, part of this data might be wrong,
due to errors in user feedback, or deprecated, due to changes in the interests
of the user. It would be best if such observations could be identified and
removed or corrected.
</p>
<p>
The dissertation proposes a method to improve the transparency of the feedback
history and make possible errors in the history salient to use user.
This is done by visualizing the feedback history together with the estimated
accuracy of each feedback. By making suspicious feedback salient, it is easier
for the user to find and correct possible errors, analogously to how
spell-checkers work in text editing software.
</p>
<p>
This is demonstrated in the toy search engine by the yellow backgrounds of
feedback that can't be adequately explained by the model. The feature is
naturally most active when there exists contradicting feeback.
</p>

<h2 class="w3-text-teal">Future work</h2>
<p>
The methods work with interpretable user models, where model parameters make
sense for the user. However, there are model families, such as neural networks,
where the model parameters are not intelligible to the user. How could models
like these be visualized and made predictable as well?
</p>

<h2 class="w3-text-teal">Relevant Publications</h2>
<p>
Antti Kangasrääsiö, Dorota Głowacka, and Samuel Kaski.
<b>Improving Controllability and Predictability of Interactive Recommendation Interfaces for Exploratory Search</b>.
In <i>Proceedings of the 20th International Conference on Intelligent User Interfaces</i>, IUI'15, pp. 247-251. ACM, 2015.
[<a href="http://dl.acm.org/citation.cfm?doid=2678025.2701371">access publication</a>]
[<a href="https://users.ics.aalto.fi/akangasr/publications/IUI2015_postprint.pdf">PDF</a>]
[<a href="https://users.ics.aalto.fi/akangasr/publications/IUI2015_slides.pdf">slides</a>]
[<a href="https://users.ics.aalto.fi/akangasr/publications/IUI2015_video.mp4">video</a>]
[<a href="https://users.ics.aalto.fi/akangasr/publications/IUI2015_reviews.txt">reviews</a>]
[<a href="https://research.aalto.fi/en/publications/improving-controllability-and-predictability-of-interactive-recommendation-interfaces-for-exploratory-search(0646a28f-e834-4c4e-a97e-29a92d7851e0).html">publication info</a>]
[<a href="http://iui.acm.org/2015/index.html">conference web page</a>]
</p>
<p>Antti Kangasrääsiö, Yi Chen, Dorota Glowacka, and Samuel Kaski.
<b>Interactive Modeling of Concept Drift and Errors in Relevance Feedback</b>.
In <i>Proceedings of the 24th Conference on User Modeling, Adaptation and Personalization</i>, UMAP'16, pp. 185-193. ACM, 2016.
[<a href="http://dx.doi.org/10.1145/2930238.2930243">access publication</a>]
[<a href="https://users.ics.aalto.fi/akangasr/publications/UMAP2016_postprint.pdf">PDF</a>]
[<a href="https://users.ics.aalto.fi/akangasr/publications/UMAP2016_poster.pdf">poster</a>]
[<a href="http://arxiv.org/abs/1603.02609">preprint</a>]
[<a href="https://users.ics.aalto.fi/akangasr/publications/UMAP2016_reviews.txt">reviews</a>]
[<a href="https://research.aalto.fi/en/publications/interactive-modeling-of-concept-drift-and-errors-in-relevance-feedback(e51c41e3-e245-4d57-afa0-1d181f6c1329).html">publication info</a>]
[<a href="http://www.um.org/umap2016/">conference web page</a>]
</p>

<h2 class="w3-text-teal">Toy Search Engine FAQ</h2>
<p>
<b>What is the search data?</b><br/>
Test data (scikit-learn) for the 20Newsgroups dataset for the <i>comp.*</i> groups.
</p>
<p>
<b>The search engine doesn't react to my query?</b><br/>
The search engine has a very limited index, and can only search for words that
exist in the index. Try some generic IT-related words.
</p>
<p>
<b>What is the search user model?</b><br/>
Ridge regression for estimating keyword weights based on feedback and their
occurence in the search documents. Vector space model for estimating document
relevance based on keyword relevance.
</p>
<p>
<b>Why is the search engine sometimes slow?</b><br/>
It's a toy model with no optimizations intended for quick demonstration of
certain usability concepts. All computations are performed in your browser.
</p>
<p>
<b>Is the source code available?</b><br/>
In <a href="https://github.com/akangasr/dissertationdemo">GitHub</a>.
</p>
</div>

<div class="w3-container" id="cognitive" style="display: none;">
<h1 class="w3-text-teal">Cognitive Model Inference</h1>

<h2 class="w3-text-teal">Cognitive Models</h2>
<p>
Cognitive models are a subset of user models distinguished by the explicit
assumptions they make of the cognitive processes and capabilities of
the user. The user is viewed as an intelligent and (mostly) rational
decision-maker, with capabilities such as memory, vision, and ability to learn.
These models, developed earlier mostly in the field of cognitive science, are
the most credible computational representation we currently have of human
cognition.
</p>
<p>
There are multiple motivating reasons for bringing these models out from the
laboratories and incorporating them into real systems. First of all, they
could offer superior predictions of user interests, goals and cognitive
capabilities. These predictions could then allow the user interface and user
experience to be personalized to each user in much higher detail than previously.
For example, search results could be visualized differently for users who are
fast at visual search, compared to those who are slower. Or users who are conducting
exploratory search could be shown a different search interface than users who are
performing directed known-item search. The possibilities are endless, and
limited only by our cabability to learn such complex models from realistic
observation data.
</p>

<h2 class="w3-text-teal">Challenges with Inference</h2>
<p>
Before cognitive models can be applied in real systems, efficient automated
inference methods need to be developed. Cognitive models often have multiple
parameter values that affect the predictions made with the models. Inference
means finding suitable values for these parameters, such that the
predictions made with the model agree with human behavior in the real world.
Inference is often done by collecting a large amount of observation data from
user experiments and then optimizing the parameter values to predict well on
this data.
</p>
<p>
The main challenge with optimizing the parameter values of cognitive models is
that the mathematical relation between the parameter values and the model
predictions -- the <i>likelihood function</i> -- is often very complex and
computationally expensive, or even impossible, to evaluate. Because of this,
many common optimization approaches, such as gradient descent, can not be
applied to cognitive model parameter inference.
</p>

<h2 class="w3-text-teal">Approximate Bayesian Computation and Bayesian Optimization</h2>
<p>
While the likelihood function is too expensive to be optimized directly, we can
optimize a surrogate function that is closely related to it: the model prediction
error. This is intuitive, as parameter values with high likelihood should lead
to more accurate predictions, and vice versa. Technically, the Approximate Bayesian
computation (ABC) framework provides us with the theory for approximating the
likelihood function using the prediction error function.
</p>
<p>
However, generating predictions from the model with various parameter value
combinations may still be computationally expensive, and the predictions often
contain stochastic noise as well. However, we can address these concerns by using
Bayesian optimization (BO), which is a method designed precisely for optimizing
stochastic and computationally expensive functions.
</p>
<p>
By combining ABC and BO, we get an inference framework that is able to estimate
the likelihood of cognitive model parameter values, which is applicable to
practically all modern cognitive models. A notable benefit of the approach is that it
also provides estimates of the parameter uncertainty across the parameter space,
and not just a point-estimate of the most likely parameter value combination.
This is a significant improvement to the previous state-of-the-art, which
comprised of manual tuning, grid search and various point-estimation methods
that did not provide any estimates of parameter uncertainty.
</p>
<br/>
<img src="abc.gif" alt="ABC inference process animation" class="figure"/>
<p>
The above animation illustrates how the inference process works. Parameter values
to be evaluated are selected by the BO acquisition function (arrow). Predictions are
generated from the model using these parameters. The discrepancy between the
predictions and the observations (prediction error) is evaluated. The Gaussian
process (GP) regression model for predicting discrepancy across the parameter space
is updated based on the new observation, and the process continues. Parameter
likelihood is estimated from the GP regression model.
</p>
<br/>
<img src="abc.png" alt="ABC inference results" class="figure"/>
<p>
The plots above show the inference results for three parameters of a cognitive
model for visual search. The plotted value is the posterior probability
(the likelihood multiplied by prior probability). The posterior is well
identified, and the results are easy to interpret. Furthermore, the as the results
are in the form of a probability distribution, they can be used as a prior in a
follow-up study.
</p>
<br/>
<img src="grid.png" alt="Grid search inference results" class="figure"/>
<p>
In comparison, the plots above show the inference results from grid search using
similar amount of computational resources. The shape of the function near its
optimum is not equally well defined due to sample locations being spread out
equally all over the parameter space. The results are not equally easy to
interpret, and prior knowledge of credible parameter values can not be easily
incorporated in the inference process. For example, the fixation duration
parameter on the bottom left has inferred value of 175 milliseconds, which is
very low when compared to the known average duration of 250 ms.
</p>

<h2 class="w3-text-teal">Future work</h2>
<p>
The method is able to perform inference for tens of parameters at a time, but
scalability to higher dimensions is still an open problem. Advances in
high-dimensional global optimization will likely help in solving this issue.
</p>

<h2 class="w3-text-teal">Relevant Publications</h2>
<p>
Antti Kangasrääsiö, Samuel Kaski.
<b>Inverse Reinforcement Learning from Summary Data.</b>
<i>Machine Learning</i>, vol. 107, pp. 1517-1535, 2018.
[<a href="https://doi.org/10.1007/s10994-018-5730-4">access publication</a>]
[<a href="https://rdcu.be/14lt">PDF</a>]
[<a href="https://arxiv.org/abs/1703.09700">preprint</a>]
-- presented in ECML PKDD 2018 journal track as plenary talk and poster
[<a href="https://users.ics.aalto.fi/akangasr/publications/ECMLPKDD2018_slides.pdf">slides</a>]
[<a href="https://users.ics.aalto.fi/akangasr/publications/ECMLPKDD2018_poster.pdf">poster</a>]
[<a href="http://www.ecmlpkdd2018.org/">conference web page</a>]
</p>
<p>
Antti Kangasrääsiö, Jussi P.P. Jokinen, Antti Oulasvirta, Andrew Howes, Samuel Kaski.
<b>Parameter Inference for Computational Cognitive Models with Approximate Bayesian Computation</b>
In review, 2018.
[<a href="https://aaltodoc.aalto.fi/bitstream/handle/123456789/34495/isbn9789526082516.pdf?sequence=1&isAllowed=y">manuscript in dissertation</a>]
</p>
<p>
Antti Kangasrääsiö, Kumaripaba Athukorala, Andrew Howes, Jukka Corander, Samuel Kaski, Antti Oulasvirta.
<b>Inferring Cognitive Models from Data using Approximate Bayesian Computation.</b>
<i>In Proceedings of the 2017 CHI Conference on Human Factors in Computing Systems</i>, CHI'17, pp. 1295-1306. ACM, 2017.
[<a href="http://dl.acm.org/citation.cfm?id=3025576">access publication</a>]
[<a href="https://users.ics.aalto.fi/akangasr/publications/CHI2017_slides.pdf">slides</a>]
[<a href="https://arxiv.org/abs/1612.00653">preprint</a>]
[<a href="https://users.ics.aalto.fi/akangasr/publications/CHI2017_reviews.txt">reviews</a>]
[<a href="https://research.aalto.fi/en/publications/inferring-cognitive-models-from-data-using-approximate-bayesian-computation(8bab3e91-13e0-4492-8eba-da42f63dee67).html">publication info</a>]
[<a href="https://chi2017.acm.org/">conference web page</a>]
</p>
<p>
Jarno Lintusaari, Henri Vuollekoski, Antti Kangasrääsiö, Kusti Skytén, Marko Järvenpää, Michael Gutmann, Aki Vehtari, Jukka Corander, Samuel Kaski.
<b>ELFI: Engine for Likelihood Free Inference.</b>
<i>Journal of Machine Learning Research</i>, vol. 19, (16):1-7, 2018.
[<a href="http://www.jmlr.org/papers/volume19/17-374/17-374.pdf">access publication</a>]
[<a href="https://arxiv.org/abs/1708.00707">preprint</a>]
[<a href="http://www.jmlr.org/papers/v19/">journal volume</a>]
</p>

<h2 class="w3-text-teal">Relevant Software</h2>
<p>
Engine for Likelihood-Free Inference (ELFI)
[<a href="https://elfi.readthedocs.io/en/latest/">documentation</a>]
[<a href="https://github.com/elfi-dev/elfi">source</a>]
</p>
<p>
Extensions / experiment repositories related to the above publications:
</br>
* ELFI experiment framework
[<a href="https://github.com/akangasr/elfie">source</a>]
<br/>
* ELFI reinforcement learning extension
[<a href="https://github.com/akangasr/elfirl">source</a>]
<br/>
* ELFI cognitive model inference experiment
[<a href="https://github.com/akangasr/cogsciabc">source</a>]
<br/>
(NB: these are not actively maintained any more and may depend on an old version of the main ELFI library)
</p>

</div>


<div class="w3-container" id="author" style="display: none;">
<h1 class="w3-text-teal">Author: Antti Kangasrääsiö</h1>
<p>
<b>Contact</b><br/>
firstname.lastname@iki.fi
</p>
<p>
<b>Links</b><br/>
<a href="https://users.ics.aalto.fi/akangasr/">Research home page</a><br/>
<a href="https://scholar.google.fi/citations?user=MvO_azMAAAAJ">Google Scholar</a><br/>
<a href="https://www.linkedin.com/in/antti-kangasr%C3%A4%C3%A4si%C3%B6-5b1a1592">LinkedIn</a>
</p>
<p>
<b>Currently working at <a href="http://cai.fi/">Curious AI</a>, Helsinki</b><br/>
Working on system identification and control, natural language understanding
and user interaction with intelligent systems.
</p>
<p>
<b>Doctor of Science (Tech.), 2018 (hopefully)</b><br/>
Studied the usability of machine learning powered systems and simulator-based
inference of realistic user models. Also studied start-ups and entrepreneurship
in the <a href="https://doctoralschool.eitdigital.eu/">EIT Digital doctoral school</a>.
Member of the
<a href="https://research.cs.aalto.fi/pml/">Probabilistic Machine Learning
research group</a>.
</p>
<p>
<b>Master of Science (Tech.), 2013</b><br/>
Studied agent-based modelling of complex decentralized systems, such as
recyclables markets and smart grids. Also mobile robotics, control theory, and
computer systems in factory automation. Member of the
<a href="https://www.aalto.fi/department-of-electrical-engineering-and-automation/information-technologies-in-industrial">
Automation IT research group</a>.
</p>
<p>
<b>Bachelor of Science (Tech.), 2011</b><br/>
Studied maths, control theory, programming languages and factory automation.
I did my thesis on online system identification and control (adaptive control).
</p>
</div>

<div class="w3-container" id="thanks" style="display: none;">
<h1 class="w3-text-teal">Thanks</h1>
<p>
Samuel Kaski for the idea of making this page<br/>
Tapio Heiskanen for the awesome mobile menu<br/>
Eero Laukkanen for technical suggestions to improve mobile-friendlyness<br/>
Hotloo Xiranood for additional CSS style suggestions<br/>
Paul Blomstedt for spotting multiple typos<br/>
Elli &lt;3
</p>

</div>


<script src="https://ajax.googleapis.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/vectorious/4.8.1/vectorious.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/rangeslider.js/2.3.2/rangeslider.min.js"></script>
<script src="https://code.jquery.com/ui/1.12.1/jquery-ui.js"></script>

<script>

var page_elements = {
  intro: document.getElementById('intro'),
  usability: document.getElementById('usability'),
  cognitive: document.getElementById('cognitive'),
  author: document.getElementById('author'),
  thanks: document.getElementById('thanks')
}

function change_page(page) {
  window.history.pushState(page, 'Page: ' + page, '?p='+page);
  display_page(page);
  toggle_mobile_menu();
}

function set_page_from_url() {
  var url = new URL(window.location.href);
  var p = url.searchParams.get("p");
  if (p in page_elements) {
    display_page(p);
  } else {
    display_page('intro');
  }
}

window.addEventListener('popstate', function(event) {
    set_page_from_url();
}, false);

function display_page(page) {
  Object.keys(page_elements).map(function(key, index) {
    if (key == page) {
      page_elements[key].style.display = 'block';
      $('html, body').animate({ scrollTop: 0 }, 'fast');
    } else {
      page_elements[key].style.display = 'none';
    }
  });
}

set_page_from_url();

var sidebar = document.querySelector('#topmenu');
var menu_bar_icon_bars = document.querySelector('.top-menu-bar-button span:first-child');
var menu_bar_icon_cross = document.querySelector('.top-menu-bar-button span:last-child');
var is_mobile_menu_visible = false;

function toggle_mobile_menu(event) {
    if (event) {
        event.preventDefault();
    }
    var is_mobile = window.innerWidth <= 1100;
    if (!is_mobile) {
        return false;
    }
    is_mobile_menu_visible = !is_mobile_menu_visible;
    var sidebar_display_value = is_mobile_menu_visible ? 'block' : 'none';
    sidebar.style.display = sidebar_display_value;
    if (is_mobile_menu_visible) {
        menu_bar_icon_bars.style.display = 'none';
        menu_bar_icon_cross.style.display = 'inline-block';
    } else {
        menu_bar_icon_bars.style.display = 'inline-block';
        menu_bar_icon_cross.style.display = 'none';
    }
}

// GLOBALS

var DATA = undefined;
var FEATURES = undefined;
var VOCABULARY = undefined;
var FEEDBACK = undefined;
var MODEL = undefined;
var MODEL0 = undefined;
var MODEL1 = undefined;
var CURRENT_FEATURE = undefined;

var USE_CONTROL = true;
var SHOW_PREDICTIONS = true;

var CONTROL_TOLERANCE = 0.1;
var CONTROL_ITERATIONS = 4;
var CONTROL_DELTA_SCALE = 2.0;
var FB_ERROR_POW = 1;
var FB_ERROR_SCALE = 500;
var MODEL_FEATURE_THRESHOLD = 0.1;
var MODEL_RIDGE = 0.1;
var MODEL_KEYWORDS_VISIBLE = 20;
var SEARCH_RESULTS_VISIBLE = 40;

// DATA LOADING

console.log("Loading data..");
var request = $.getJSON("data.json", function() {
  console.log("Processing data..");
  DATA = Array.from(request.responseJSON.data).map(function(item) {
    return {
      text: item.text,
      features: item.features.map(function(feature) {
        return {
          idx: parseInt(feature.idx),
          value: parseFloat(feature.value)
        }
      })
    }
  });
  VOCABULARY = Array.from(request.responseJSON.vocabulary);
  FEATURES = Matrix.zeros(VOCABULARY.length, DATA.length);
  DATA.map(function(item, idx) {
    item.features.map(function(feature) {
      FEATURES.set(feature.idx, idx, feature.value);
    });
  });
  console.log("Data loaded");
})

// UPDATING

function update_all() {
  if (USE_CONTROL) {
    var value = train_model_control(FEEDBACK);
    MODEL = value[0];
    FEEDBACK = value[1];
  } else {
    MODEL = train_model(FEEDBACK);
  }
  display_history(FEEDBACK, MODEL);
  display_model(MODEL);
  display_search_results(MODEL);
  clear_search_item();
}

function remove_feedback_and_update(fb_id) {
  if (FEEDBACK.length > 1) {
    FEEDBACK.splice(fb_id,1);
    update_all();
  } else {
    console.log("Can't remove last feedback");
  }
}

// MODEL TRAINING

function train_pred_models(feedback, kw_idx, fb_idx=undefined) {
  fb0 = feedback.slice();
  fb1 = feedback.slice();
  if (fb_idx !== undefined) {
    fb0[fb_idx] = {feature:kw_idx,value:-1.0,weight:1.0};
    fb1[fb_idx] = {feature:kw_idx,value:1.0,weight:1.0};
  } else {
    fb0.push({feature:kw_idx,value:-1.0,weight:1.0});
    fb1.push({feature:kw_idx,value:1.0,weight:1.0});
  }
  return [train_model(fb0), train_model(fb1)]
}

function train_model_control(fb) {
  let last_idx = fb.length - 1;
  let ref_fb = fb[last_idx];
  if (ref_fb.weight > 1.0) {
    // don't re-control
    let model = train_model(fb);
    return [model, fb];
  }
  for (let i = 0; i < CONTROL_ITERATIONS; i++) {
    var model = train_model(fb);
    let err = model.Yhat.get(ref_fb.feature, 0) - ref_fb.value;
    if (Math.abs(err) > CONTROL_TOLERANCE) {
      console.log("Control error: " + err.toFixed(3));
      ref_fb.weight = ref_fb.weight * CONTROL_DELTA_SCALE;
      fb[last_idx] = ref_fb;
    } else {
      console.log("Control error within tolerance");
      return [model, fb];
    }
  }
  return [model, fb];
}

function train_model(fb) {
  console.log("Training model..");
  // compiling matrices
  let X = Matrix.zeros(fb.length, DATA.length);
  let S = Matrix.identity(fb.length);
  let Y = Matrix.zeros(fb.length, 1);
  fb.map(function(fb_item, row) {
    let feature_idx = fb_item.feature;
    for (let i = 0; i < DATA.length; i++) {
      let fv = FEATURES.get(feature_idx, i);
      if (fv > 0) {
        X.set(row, i, fv);
      }
    }
    S.set(row, row, fb_item.weight);
    Y.set(row, 0, fb_item.value);
  });
  // collecting near-zero features
  var skipcols = [];
  var threshold = MODEL_FEATURE_THRESHOLD;
  range(DATA.length).map(function(col) {
    var sum = 0;
    range(fb.length).map(function(row) {
      sum += X.get(row, col);
    })
    if (sum < threshold) {
      skipcols.push(col);
    }
  })
  // removing near-zero features
  let Xs = Matrix.zeros(fb.length, DATA.length-skipcols.length);
  fb.map(function(fb_item, row) {
    let cols_skipped = 0;
    for (let i = 0; i < DATA.length; i++) {
      if (skipcols.includes(i)) {
        cols_skipped += 1;
        continue;
      }
      let fv = X.get(row, i);
      if (fv > 0) {
        Xs.set(row, i-cols_skipped, fv);
      }
    }
  });
  // training model
  let XtS = Xs.transpose().multiply(S);
  let Id = Matrix.identity(DATA.length-skipcols.length).scale(MODEL_RIDGE);
  let XtSXId = XtS.multiply(Xs).add(Id);
  let XtSY = XtS.multiply(Y);
  let Ws = XtSXId.solve(XtSY);
  // adding zeroes for near-zero features
  let W = Matrix.zeros(DATA.length, 1);
  cols_skipped = 0;
  range(DATA.length).map(function(col) {
    if (skipcols.includes(col)) {
      W.set(col, 0, 0);
      cols_skipped += 1;
    } else {
      W.set(col, 0, Ws.get(col-cols_skipped, 0));
    }
  });
  // compute keyword weights
  let Yhat = FEATURES.multiply(W);
  return {
    W: W,
    Yhat: Yhat
  };
}

function generate_initial_feedback(query) {
  console.log("Generating initial feedback..");
  let words = query.split(' ');
  let ret = [];
  words.map(function(word) {
    let voc_idx = VOCABULARY.indexOf(word);
    if (voc_idx > -1) {
      console.log("Term '" + word + "' found in index");
      ret.push({feature:voc_idx,value:1.0,weight:1.0})
    } else {
      console.log("Term '" + word + "' not found in index");
    }
  });
  return ret;
}

// UTILS

function arg_max(array) {
  return array.map((x, i) => [x, i]).reduce((r, a) => (a[0] > r[0] ? a : r))[1];
}

function descending_sorted_index(arr) {
  let arr_idx = arr.map(function(v, i) {
    return {i:i, v:v}
  });
  arr_idx.sort(function(a,b) {
    if (a.v < b.v) {
      return 1;
    }
    if (a.v > b.v) {
      return -1;
    }
    return 0;
  });
  return arr_idx.map(function(o) {
    return o.i;
  })
}

function range(n) {
  var x = [];
  if (n === 0) {
    return x;
  }
  var i = 0;
  while (x.push(i++) < n) {};
  return x;
}

// UI INPUTS

function toggle_show_model() {
  if (document.getElementById('show-model-checkbox').checked) {
      document.getElementById('search-model').style.visibility = 'visible';
      document.getElementById('search-history').style.visibility = 'visible';
  } else {
      document.getElementById('search-model').style.visibility = 'hidden';
      document.getElementById('search-history').style.visibility = 'hidden';
  }
}

function toggle_show_predictions() {
  if (document.getElementById('show-predictions-checkbox').checked) {
      SHOW_PREDICTIONS = true;
  } else {
      SHOW_PREDICTIONS = false;
  }
}

function toggle_use_control() {
  if (document.getElementById('use-control-checkbox').checked) {
      USE_CONTROL = true;
  } else {
      USE_CONTROL = false;
  }
}

$('#search-box').keypress(function(event) {
  if (event.keyCode == 13 || event.which == 13) {
    let query = document.getElementById('search-box').value;
    FEEDBACK = generate_initial_feedback(query);
    if (FEEDBACK.length == 0) {
      console.log("Failed to initialize model");
      return;
    }
    update_all();
  }
});

// UI OUTPUTS

function display_search_results(model) {
  let searchResultsDiv = document.getElementById("search-results");
  searchResultsDiv.innerHTML = '';
  let para = document.createElement("div");
  para.innerHTML = 'Top results:';
  para.className = "search-result-header";
  searchResultsDiv.appendChild(para);
  let scores = FEATURES.transpose().multiply(model.Yhat);
  let results = descending_sorted_index(scores.transpose().toArray()[0]).slice(0,SEARCH_RESULTS_VISIBLE);
  results.map(function(id) {
    para = document.createElement("p");
    para.className = "search-result-title";
    let subject = DATA[id].text.match(/Subject: ([^\n\r]*)/)[1];
    para.innerHTML = subject;
    para.onclick = function() {
      display_search_item(id);
    }
    searchResultsDiv.appendChild(para);
  })
}

function clear_search_item() {
  let searchItemDiv = document.getElementById("search-item");
  searchItemDiv.innerHTML += '';
}

function display_search_item(item_id) {
  let searchItemDiv = document.getElementById("search-item");
  searchItemDiv.innerHTML = '';
  let para = document.createElement("div");
  para.className = "search-result-text";
  let text = DATA[item_id].text.replace(/(?:\r\n|\r|\n)/g, '<br/>');
  para.innerHTML = text;
  searchItemDiv.appendChild(para);
}

function display_history(feedback, model) {
  let historyDiv = document.getElementById("search-history");
  historyDiv.innerHTML = '';
  let para = document.createElement("div");
  para.innerHTML = 'Feedback:';
  para.className = "search-history-header";
  historyDiv.appendChild(para);
  feedback.map(function(fb, idx) {
    let pred_value = model.Yhat.get(fb.feature, 0);
    create_keyword_element_to(historyDiv, fb.feature, fb.value, 'history', idx, fb.weight, pred_value);
  })
}

function display_model(model) {
  let modelDiv = document.getElementById("search-model");
  modelDiv.innerHTML = '';
  let para = document.createElement("div");
  para.innerHTML = 'Model:';
  para.className = "search-model-header";
  modelDiv.appendChild(para);
  let idx = descending_sorted_index(model.Yhat.transpose().toArray()[0]);
  idx.slice(0,MODEL_KEYWORDS_VISIBLE).map(function(i) {
    create_keyword_element_to(modelDiv, i, model.Yhat.get(i, 0), 'model');
  })
}

function update_keyword_elements(feedback, model) {
  $("div").map(function() {
      if(this.id.match(/keyword-slider-model/)) {
        let kw_idx = parseInt($(this).attr('kw_idx'));
        if (kw_idx === CURRENT_FEATURE) {
          return;
        }
        let pred_value = model.Yhat.get(kw_idx, 0);
        $(this).slider({
          value: Math.max(-10, Math.min(10, parseInt(10.0*pred_value)))
        });
      }
      if(this.id.match(/keyword-div-history/)) {
        let value = parseFloat($(this).attr('fb_val'));
        let kw_idx = parseInt($(this).attr('kw_idx'));
        let pred_value = model.Yhat.get(kw_idx, 0);
        let c = color_for_error(value-pred_value);
        $(this).children().first().css("backgroundColor", c);
      }
  });
}

function color_for_error(err) {
  let e = Math.pow(err, FB_ERROR_POW);
  let c = 255 - parseInt(Math.min(255, e*FB_ERROR_SCALE));
  return "rgb(255,255,"+c+")";
}

function create_keyword_element_to(parent, kw_idx, value, type, fb_idx=undefined, fb_weight=undefined, pred_value=undefined) {
  let div = document.createElement("div");
  div.className = "keyword-item";
  let kw_name = VOCABULARY[kw_idx];
  let text = document.createElement("div");
  text.setAttribute("class", "keyword-item-name");
  if (fb_idx !== undefined) {
    text.setAttribute("onclick", "remove_feedback_and_update(" + fb_idx + ")");
    text.setAttribute("title", "Click to remove feedback");
    text.style.cursor = "pointer";
  }
  if (fb_weight !== undefined && fb_weight !== 1.0) {
    text.innerHTML = kw_name + ' (x' + parseInt(fb_weight) + ')';
  } else {
    text.innerHTML = kw_name;
  }
  let div_id = "keyword-div-" + type + '-' + kw_name + '-' + parseInt(Math.random()*1000000);
  let slider_id = "keyword-slider-" + type + '-' + kw_name + '-' + parseInt(Math.random()*1000000);
  if (pred_value) {
    let c = color_for_error(value-pred_value);
    text.style.backgroundColor = c;
    div.setAttribute("fb_val", value);
    div.setAttribute("id", div_id);
    div.setAttribute("kw_idx", kw_idx);
  }
  let slider = document.createElement("div");
  slider.setAttribute("id", slider_id);
  slider.setAttribute("kw_idx", kw_idx);
  slider.setAttribute("class", "keyword-slider");
  div.appendChild(text);
  div.appendChild(slider);
  parent.appendChild(div);
  $(function() {
    $("#" + slider_id).slider({
      min: -10,
      max: 10,
      value: Math.max(-10, Math.min(10, parseInt(10.0*value))),
      start: function( event, ui ) {
        if (SHOW_PREDICTIONS) {
          CURRENT_FEATURE = kw_idx;
          var value = train_pred_models(FEEDBACK, kw_idx, fb_idx);
          if (CURRENT_FEATURE === kw_idx) {
            MODEL0 = value[0];
            MODEL1 = value[1];
          }
        }
      },
      slide: function( event, ui ) {
        if (MODEL0 === undefined || MODEL1 === undefined) {
          return;
        }
        let scale1 = (1.0+ui.value/10.0)/2.0;
        let scale0 = 1.0 - scale1;
        let W0s = new Matrix(MODEL0.W)
        W0s.scale(scale0)
        let W1s = new Matrix(MODEL1.W)
        W1s.scale(scale1)
        let Yhat0s = new Matrix(MODEL0.Yhat)
        Yhat0s.scale(scale0)
        let Yhat1s = new Matrix(MODEL1.Yhat)
        Yhat1s.scale(scale1)
        pred_model = {
          W: W0s.add(W1s),
          Yhat: Yhat0s.add(Yhat1s)
        }
        update_keyword_elements(FEEDBACK, pred_model);
        display_search_results(pred_model);
      },
      stop: function( event, ui ) {
        MODEL0 = undefined;
        MODEL1 = undefined;
        CURRENT_FEATURE = undefined;
        let fb = {feature:kw_idx,value:ui.value/10.0,weight:1.0};
        if (fb_idx !== undefined) {
          if (FEEDBACK.length > 1) {
            FEEDBACK.splice(fb_idx,1);
            FEEDBACK.push(fb);
          } else {
            FEEDBACK[fb_idx] = fb;
          }
        } else {
          FEEDBACK.push(fb);
        }
        update_all();
      }
    });
  });
}

</script>

</body>
</html>
